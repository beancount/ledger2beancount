#!/usr/bin/perl

# Copyright (C) 2016-2018 Stefano Zacchiroli <zack@upsilon.cc>
#           (C) 2018 Martin Michlmayr <tbm@cyrius.com>
# License: GNU General Public License (GPL), version 3 or above

# convert a ledger-cli main ledger file to beancount format

use strict;
use warnings;

use Carp::Assert;
use Date::Calc qw(Add_Delta_Days);
use POSIX qw(ceil);


# list of frequently used currencies (not *all* used currencies)
my @operating_currencies = ("EUR");

# beancount file listing plugins to load
my $beancount_plugins = "plugins.beancount";

# mapping of ledger metadata key to corresponding beancount key
my %metadata_map = (
    'label'   => 'bank-label',
    'x-payee' => 'payee',
    'x-payer' => 'payer',
    );

# mapping of ledger account names to valid beancount accounts
my %account_map = (
    'Equity:Opening balance' => 'Equity:Opening-Balance',
    );

# mapping of ledger commodities to valid beancount commodities
my %commodity_map = (
    );

# metadata tags (*after* above mapping) used for specific purposes
my $payee_tag = 'payee';
my $payer_tag = 'payer';
# You can set the following metadata tags to an empty string if you
# don't want the metadata to be added to beancount.
my $altdate_tag = 'alt-date';
my $code_tag = 'code';


# regular expression snippets used for ledger parsing
my $date_RE = qr/[0-9-]+/;
my $txn_header_RE = qr/^(?<date>$date_RE)(=(?<altdate>$date_RE))?\s*(?<flag>[*!])?(\s+\((?<code>.*?)\))?\s+(?<narration>.*)/;
my $tags_RE = qr/(?<tags>[\w:-]+)/;
my $account_RE = qr/[A-Z].*?/;
my $value_RE = qr/[\d.-]+/;
my $commodity_RE = qr/[A-Za-z0-9_"]+/;
my $amount_RE = qr/(?<value>$value_RE)\s+(?<commodity>$commodity_RE)/;
my $comment_RE = qr/;\s*(?<comment>.*)/;
my $metadata_RE = qr/^;\s*(?<key>[\w-]+):(?<typed>:)?\s*(?<value>.*)/;
my $posting_RE = qr/(?<posting>(?<account>$account_RE)(  |\t)\s*(?<amount>$amount_RE))/;
my $price_RE = qr/^P\s+(?<date>$date_RE)\s+(\d\d:\d\d(:\d\d)?\s+)?(?<commodity1>$commodity_RE)\s+(?<value>$value_RE)\s+(?<commodity2>$commodity_RE)/;


# indentation length, for ledger and beancount
my $beancount_indent = 2;
my $ledger_indent = 4;

# indent some content at a given depth in beancount style
sub indent($$) {
    my ($depth, $content) = @_;

    return ' ' x ($depth * $beancount_indent) . $content;
}


sub escape_beancount_string($) {
    my ($s) = @_;
    $s =~ s/"/\\"/g;
    return $s;
}

# return a beancount string literal, with a given content
sub mk_beancount_string($) {
    my ($s) = @_;
    return '"' . escape_beancount_string($s) . '"';
}

# parse a ledger value. Usually to extract "semantic" values from typed
# metadata
sub parse_ledger_value($) {
    my ($raw) = @_;
    my $value;

    if ($raw =~ /^\[(?<date>\d{4}-\d{2}-\d{2})\]$/) {
	$value = $+{date};
    } else {
	$value = $raw;
    }

    return $value;
}


# Simple parsing state machine: we need to look ahead for payee metadata, as in
# beancount they appear on the first line of a transaction, whereas in ledger
# they appear as a regular metadata ("x-payee"). The following functions
# support the parsing state machine for this:
my ($in_txn, $in_postings,
    %cur_txn_header, @cur_txn_lines, @cur_txn_assertions);


# reset current parsing state, reinitializing it to the empty state
sub reset_cur_txn() {
    $in_txn = 0;  # whether we are currently in a txn block
    $in_postings = 0;  # whether we are currently within postings (i.e., past txn metadata)
    %cur_txn_header = ();  # txn header, i.e., its first line
    @cur_txn_lines = ();  # txn lines, i.e., all lines except the header
    @cur_txn_assertions = ();  # balance assertions related to txn
}
reset_cur_txn();


# pretty print the transaction header (i.e., its first line) in beancount
# format
sub pp_cur_header() {
    my $buf = "";

    $buf .= $cur_txn_header{date} . " ";
    $buf .= $cur_txn_header{flag} . " " if $cur_txn_header{flag};
    if (exists $cur_txn_header{payee}) {
	$buf .= (mk_beancount_string $cur_txn_header{payee}) . " ";
    }
    $buf .= mk_beancount_string $cur_txn_header{narration};

    return $buf;
}

# pretty print subsequent lines (all but the first) of a transaction, in
# beancount format
sub pp_cur_lines() {
    return (join "\n", @cur_txn_lines) . "\n";
}

# pretty print pending balance assertions, in beancount format
sub pp_cur_assertions() {
    return (join "\n", @cur_txn_assertions) . "\n";
}

# pretty print a single metadata key/value paris, in beancount format
sub pp_metadata($$) {
    my ($key, $value) = @_;

    return "$key: $value";
}

# pretty print in-transaction tags, in beancount format
sub pp_tags(@) {
    my @tags = @_;

    # XXX workaround for the fact that per-posting tags are currently not
    # allowed.  See:
    # https://groups.google.com/forum/#!topic/beancount/XPtFOnqCVws
    return "tags: \"" . join(', ', @tags) . "\"";
}

# dump the current parsing state to stdout. Used for debugging purposes only
sub dump_cur_txn() {
    if ($in_txn) {
	print "D: cur_header: " . pp_cur_header() . "\n";
	print "D: cur_lines_begin\n";
	print pp_cur_lines();
	print "D: cur_lines_end\n";
    } else {
	print "D: no txn\n";
    }
}


# set the current transaction header (= first line), overriding the previous
# value (which should *usually* be empty, but it is the caller responsibility
# to ensure this is the case)
sub push_header($$$) {
    my ($date, $flag, $narration) = @_;

    $in_txn = 1;
    $cur_txn_header{date} = $date;
    $cur_txn_header{flag} = $flag;
    $cur_txn_header{narration} = $narration;
}

# set the current transaction payee, complementing the transaction header
sub push_payee($) {
    my ($payee) = @_;
    $cur_txn_header{payee} = $payee;
}

# add a transaction line. Call this multiple times to accmulate lines that will
# be emitted as soon as the transaction is over
sub push_line($$) {
    my ($depth, $line) = @_;

    $in_postings = 1 if $line =~ /^$posting_RE/;
    push @cur_txn_lines, indent($depth, $line);
}

# add a balance assertion to be published at the end of current transaction
sub push_assertion($$) {
    my ($account, $amount) = @_;

    # beancount evalutes balance assertions at the beginning of the day,
    # whereas ledger evalutes them at the end of the txn. So we schedule the
    # balance assertion for the *after* the origin txn. This assumes that there
    # are no *other* txn in the same day that change the balance again.
    my $assertion_date = sprintf("%04d-%02d-%02d",
				 Add_Delta_Days(split(/-/, $cur_txn_header{date}), 1));
    push @cur_txn_assertions, "$assertion_date balance $account  $amount";
}

# add a metadata line. Wrapper around push_line() for metadata
sub push_metadata($$$) {
    my ($depth, $key, $value) = @_;
    push_line $depth, pp_metadata($key, $value);
}

# add a comment line. Wrapper around push_line() for comments
sub push_comment($$) {
    my ($depth, $comment) = @_;

    # XXX as a workaround for bug
    # https://bitbucket.org/blais/beancount/issues/143/full-line-comments-not-allowed-within
    # we store comments as "comment: text" metadata entries (rather than
    # beancount comments)

    if (@cur_txn_lines and
	$cur_txn_lines[-1] =~ /^\s*comment:\s+"(?<comment>.*)"/s) {
	# last pushed (logical) line was a comment too, treat it as a
	# multi-line comment and append current comment payload to it
	pop @cur_txn_lines;
	$comment = "$+{comment}\n"
	    . indent($depth + 1, escape_beancount_string($comment));
	$comment = "\n" . indent($depth +1, $comment)
	    unless $+{comment} =~ /^\n/;
	push_metadata $depth, "comment", "\"$comment\"";
    } else {
	push_metadata $depth, "comment", mk_beancount_string($comment);
    }
}


# return a pretty printed transaction, reseting the current parsing state. This
# is usually called as soon as the end of a transaction (usually an empty line)
# is encountered
sub pop_txn() {
    my $buf = "";

    $buf .= pp_cur_header() . "\n";
    $buf .= pp_cur_lines();
    $buf .= "\n" . pp_cur_assertions() if @cur_txn_assertions;

    reset_cur_txn();

    return $buf;
}


# map a (ledger) metadata key to the desired (beancount) metadata key. Relies
# on the global %metadata_map hash
sub map_metadata($) {
    my ($key) = @_;

    if (exists $metadata_map{$key}) {
	return $metadata_map{$key};
    } else {
	return $key;
    }
}


# emit a single line
sub print_line($$) {
    my ($depth, $line) = @_;

    print indent($depth, $line), "\n";
}


# emit fixed beancount header (due to a current beancount limitation, options
# and plugins must be in the top-level file)
print "option \"operating_currency\" \"$_\"\n" foreach @operating_currencies;
print "include \"avg-cost-adjustments.beancount\"\n";
print <<'EOT';

; plugins listed here because they don't work if declared in included files
; see: https://bitbucket.org/blais/beancount/issues/147
EOT
open(my $plugins, '<', $beancount_plugins)
    or die "cannot open beancount plugins file: $beancount_plugins\n";
print $_ while (<$plugins>);
print "\n";
close $plugins;


# MAIN CONVERSION LOOP

while (my $l = <>) {
    # print "D: line: ", "\n"; dump_cur_txn(); print "\n";

    # handle line indentation once and for all
    chomp $l;
    $l =~ /^(?<indent>\s*)(?<line>.*)/;
    my $depth = ceil(length($+{indent}) / $ledger_indent);
      # round up with ceil() because we mix 4 (postings) and 2 (posting tags) indent in ledger
    $l = $+{line};

    if ($l =~ /^include\s+(?<filename>.*)\.ledger/) {  # include
	print_line $depth, "include \"$+{filename}.beancount\"";
    } elsif ($l =~ /$txn_header_RE/) {  # txn header
	push_header $+{date}, $+{flag} ? $+{flag} : "", $+{narration};
	push_metadata $depth + 1, $altdate_tag, $+{altdate} if defined $+{altdate} && defined $altdate_tag;
	push_metadata $depth + 1, $code_tag, mk_beancount_string $+{code} if defined $+{code} && defined $code_tag;
    } elsif ($l =~ /$metadata_RE/ && $in_txn) {  # metadata comment
	my $key = map_metadata(lc($+{key}));
	my $value;
	if (defined($+{typed})) {
	    $value = parse_ledger_value $+{value};
	} else {
	    $value = mk_beancount_string $+{value};
	}
	if (not $in_postings and ($key eq $payee_tag or $key eq $payer_tag)) {
	    # ASSUMPTION: payer_tag always occurs later than payee_tag, which
	    # is currently enforced in our leder. This is to guarantee that we
	    # promote payers to payees, because that's the sensible thing to do
	    # with Beancount
	    push_payee $+{value};
	} else {
	    push_metadata $depth, $key, $value;
	}
    } elsif ($l =~ /^$comment_RE\s+:$tags_RE:\s*$/
	     or $l =~ /^;\s+:$tags_RE:\s+(?<comment>.*)$/) {
    	# tags comment
    	if ($in_txn) {
	    push_line $depth, pp_tags(split(/:/, $+{tags}));
	    push_comment $depth, $+{comment} if $+{comment} ne "";
    	} else {
    	    print_line $depth, $l;
    	}
    } elsif ($l =~ /^$comment_RE/) {  # (every other) comment
	$in_txn ? push_comment $depth, $+{comment} : print_line $depth, $l;
    } elsif ($l =~ /^$price_RE/) {
	my $commodity1 = $+{commodity1};
	$commodity1 = $commodity_map{$+{commodity1}} if exists $commodity_map{$+{commodity1}};
	my $commodity2 = $+{commodity2};
	$commodity2 = $commodity_map{$+{commodity2}} if exists $commodity_map{$+{commodity2}};
	$l = "$+{date} price $commodity1 $+{value} $commodity2";
	$l =~ s/"//g;
	print_line $depth, $l;
    } elsif ($l =~ /^$posting_RE/ || $l =~ /^(?<account>$account_RE)$/) {
	# Replace ledger account names with corresponding beancount account names
	my $beancount_account = $+{account};
	$beancount_account = $account_map{$+{account}} if exists $account_map{$+{account}};
	$l =~ s/$+{account}/$beancount_account/;

	if ($l =~ /$amount_RE/) {
	    my $commodity = $+{commodity};
	    my $beancount_commodity = $commodity;
	    # beancount doesn't allow quoted commodities
	    $beancount_commodity =~ s/"//g;
	    # Replace ledger commodities with corresponding beancount commodities
	    $beancount_commodity = $commodity_map{$commodity} if exists $commodity_map{$commodity};
	    $l =~ s/$commodity/$beancount_commodity/;
	}

	if ($l =~ /^$posting_RE\s*=\s*(?<assertion>$amount_RE)/) {
	    # posting with balance assertion
	    assert $in_txn;
	    push_line $depth, $+{posting};
	    push_assertion $+{account}, $+{assertion};
	} elsif ($l =~ /^$posting_RE(\s+\{\s*(?<lot_price>$amount_RE)\s*\})?\s+(\[(?<date>$date_RE)\])?\s?@\s+(?<unit_price>$amount_RE)/) {
	    # posting with unit price and optional lot price
	    # XXX refactor/merge with previous regexp case
	    assert $in_txn;
	    my $date = "";
	    $date = ", $+{date}" if (defined $+{date});
	    if (not defined $+{lot_price}) {
		# No ledger {lot price}, only per-unit @price. Convert to a
		# beancount {cost}, which is required to ensure cost basis
		$l = "$+{posting} {$+{unit_price}$date}";
	    } elsif ($+{lot_price} eq $+{unit_price}) {
		# ledger requires you to specify both {lot price} and @price
		# due to a bug.  If both are the same, ignore the @price.
		$l = "$+{posting} {$+{unit_price}$date}";
	    } else {
		# Both ledger {lot price} and per-unit @price. Convert to a
		# beancount {cost} with @price, to compute gains.
		$l = "$+{posting} {$+{lot_price}$date} @ $+{unit_price}";
	    }
	    push_line $depth, $l;
	} else {
	    push_line $depth, $l;
	}
    } elsif ($l =~ /^$/) {  # empty line
	print pop_txn() if $in_txn;
	print "\n";
    } else {  # everything else
	$in_txn ? push_line $depth, $l : print_line $depth, $l;
    }
}

# emit last transaction, if it's still active when reaching EOF
print pop_txn() if $in_txn;
